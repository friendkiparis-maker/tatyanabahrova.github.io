<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2048</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #fff;
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    canvas {
      background: rgba(240, 240, 240, 0.15);
      border: 1px solid rgba(0,0,0,0.08);
      border-radius: 6px;
      display: block;
      margin: 0 auto;
    }
    button {
      margin-top: 18px;
      background: #FF9800;
      color: white;
      border: none;
      padding: 9px 18px;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      font-size: 16px;
    }
    button:hover {
      background: #F57C00;
    }
    .instructions {
      color: #222;
      margin-top: 14px;
      font-weight: bold;
      text-align: center;
      max-width: 300px;
      line-height: 1.4;
    }
    h1 {
      color: #222;
      margin-bottom: 12px;
    }
  </style>
</head>
<body>
  <h1>2048</h1>
  <canvas id="game2048" width="300" height="300"></canvas>
  <button onclick="initGame()">Новая игра</button>
  <div class="instructions">Используй стрелки на клавиатуре, чтобы сдвигать плитки</div>

  <script>
    let canvas, ctx, grid;

    function initGame() {
      grid = [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0]
      ];
      addRandomTile();
      addRandomTile();
      draw();
    }

    function addRandomTile() {
      const empty = [];
      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          if (grid[y][x] === 0) empty.push({x, y});
        }
      }
      if (empty.length > 0) {
        const pos = empty[Math.floor(Math.random() * empty.length)];
        grid[pos.y][pos.x] = Math.random() < 0.9 ? 2 : 4;
      }
    }

    function draw() {
      ctx.fillStyle = 'rgba(240, 240, 240, 0.15)';
      ctx.fillRect(0, 0, 300, 300);

      const colors = {
        2: '#eee4da', 4: '#ede0c8', 8: '#f2b179', 16: '#f59563',
        32: '#f67c5f', 64: '#f65e3b', 128: '#edcf72', 256: '#edcc61',
        512: '#edc850', 1024: '#edc53f', 2048: '#edc22e', default: '#cdc1b4'
      };
      const textColors = {
        2: '#776e65', 4: '#776e65', default: '#f9f6f2'
      };

      const SIZE = 70, GAP = 8, OFFSET = 10;
      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          const val = grid[y][x];
          if (val === 0) continue;
          const posX = OFFSET + x * (SIZE + GAP);
          const posY = OFFSET + y * (SIZE + GAP);
          ctx.fillStyle = colors[val] || colors.default;
          ctx.fillRect(posX, posY, SIZE, SIZE);
          ctx.font = 'bold 24px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = textColors[val] || textColors.default;
          ctx.fillText(String(val), posX + SIZE / 2, posY + SIZE / 2);
        }
      }
    }

    function move(direction) {
      let moved = false;
      let newGrid = Array(4).fill().map(() => Array(4).fill(0));

      for (let i = 0; i < 4; i++) {
        let row = direction === 'left' || direction === 'right'
          ? grid[i].slice()
          : grid.map(r => r[i]);

        if (direction === 'right' || direction === 'down') row.reverse();

        let filtered = row.filter(v => v !== 0);
        let merged = [];
        for (let j = 0; j < filtered.length; j++) {
          if (j < filtered.length - 1 && filtered[j] === filtered[j + 1]) {
            merged.push(filtered[j] * 2);
            j++;
          } else {
            merged.push(filtered[j]);
          }
        }

        while (merged.length < 4) merged.push(0);
        if (direction === 'right' || direction === 'down') merged.reverse();

        if (direction === 'left' || direction === 'right') {
          newGrid[i] = merged;
        } else {
          for (let k = 0; k < 4; k++) newGrid[k][i] = merged[k];
        }
      }

      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          if (grid[y][x] !== newGrid[y][x]) moved = true;
        }
      }

      if (moved) {
        grid = newGrid;
        addRandomTile();
        draw();
      }
    }

    function handleKey(e) {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
        e.preventDefault();
        if (e.key === 'ArrowLeft') move('left');
        if (e.key === 'ArrowRight') move('right');
        if (e.key === 'ArrowUp') move('up');
        if (e.key === 'ArrowDown') move('down');
      }
    }

    document.addEventListener('keydown', handleKey);

    window.onload = () => {
      canvas = document.getElementById('game2048');
      ctx = canvas.getContext('2d');
      initGame();
    };
  </script>
</body>
</html>